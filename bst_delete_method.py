# -*- coding: utf-8 -*-
"""BST_Delete_Method.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11TGbNOUtX0ER8WAbNFkIPKabO4ItHNbK

<a href="https://colab.research.google.com/github/mdkamrulhasan/data_structure_and_algorithms/blob/main/notebooks/bst_recursion_263.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>

Define a tree Node
"""

class bstNode:
  def __init__(self, x):
    self.data = x
    self.left_child = None
    self.right_child = None

"""Define BST

Some (deletion) adapted from [link text](https://https://www.w3resource.com/python-exercises/data-structures-and-algorithms/python-binary-search-tree-exercise-4.php)
"""

class myBST:
  def __init__(self):
    self.root = None

  def insert(self, root, key):
    # If the tree is empty, return a new node
    if root is None:
        return bstNode(key)
    # Otherwise, recur down the tree
    if key < root.data:
        root.left_child = self.insert(root.left_child, key)
    else:
        root.right_child = self.insert(root.right_child, key)
    # return the (unchanged) root pointer
    return root

  def pre_order(self, root):
    if root:
      print(root.data)
      self.pre_order(root.left_child)
      self.pre_order(root.right_child)

  def in_order(self, root):
    if root:
      self.in_order(root.left_child)
      print(root.data)
      self.in_order(root.right_child)

  def post_order(self, root):
    if root:
      self.post_order(root.left_child)
      self.post_order(root.right_child)
      print(root.data)


  def delete(self, root, key):
    # enter your code here
    if root is None:
      return root

    #calls for node to be deleted
    if key < root.data:
      root.left_child = self.delete(root.left_child, key)
    elif key > root.data:
      root.right_child = self.delete(root.right_child, key)
    else:
      #One child or no child
      if root.left_child is None:
        return root.right_child
      elif root.right_child is None:
        return root.left_child

    #two children
      else:
        successorParent = root

        #find successor
        successor = root.right_child
        while successor.left_child is not None:
          successorParent = successor
          successor = successor.left_child

        #delete successor, if none, assign to right root
        if successorParent != root:
          successorParent.left_child = successor.right_child
        else:
          successorParent.right_child = successor.right_child

        #copy successor data to root
        root.key = successor.key

        #delete successor and return root
        del successor
        return root

#References
#https://www.youtube.com/watch?v=gcULXE7ViZw&t=889s
#https://www.geeksforgeeks.org/deletion-in-binary-search-tree/

my_tree = myBST()
my_tree.root = my_tree.insert(my_tree.root, 6)
my_tree.root = my_tree.insert(my_tree.root, 4)
my_tree.root = my_tree.insert(my_tree.root, 100)

my_tree.insert(None, 6)
my_tree

my_tree.root.data

my_tree.pre_order(my_tree.root)

my_tree.in_order(my_tree.root)

my_tree.post_order(my_tree.root)

my_tree.delete(my_tree.root, 4)

my_tree.pre_order(my_tree.root)

my_tree.root = my_tree.insert(my_tree.root, 8)
my_tree.root = my_tree.insert(my_tree.root, 3)

my_tree.pre_order(my_tree.root)

# my_tree.delete(my_tree.root, 6)

# my_tree.pre_order(my_tree.root)

# my_tree.delete(my_tree.root, 100)

# my_tree.pre_order(my_tree.root)