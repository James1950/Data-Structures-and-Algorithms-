# -*- coding: utf-8 -*-
"""Merge_Sort_Assignment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13_qqp72UpJBTyp4z6_g666DHpLZBZY8a
"""

#Merge Sort

def merge_sort(array):

  if len(array) > 1:

    #Grab left, middle, right
    middle_array = len(array) // 2
    leftHalf_array = array[:middle_array]
    rightHalf_array = array[middle_array:]

    #print halves
    print(leftHalf_array)
    print(rightHalf_array)

    #recursion (break down) going to grab left, middle, right each time
    merge_sort(leftHalf_array)
    merge_sort(rightHalf_array)


    i = 0
    j = 0
    k = 0

    #putting the array back together (shown with print statements)
    #move i and j up until out of line
    while i < len(leftHalf_array) and j < len(rightHalf_array):
      if leftHalf_array[i] < rightHalf_array[j]:
        array[k] = leftHalf_array[i]
        print(array[k])
        i += 1
      else:
        array[k] = rightHalf_array[j]
        print(array[k])
        j += 1
      k += 1

    #if i is still in line
    while i < len(leftHalf_array):
      array[k] = leftHalf_array[i]
      print(array[k])
      i += 1
      k += 1

    #if j is still in line
    while j < len(rightHalf_array):
      array[k] = rightHalf_array[j]
      print(array[k])
      j += 1
      k += 1


unsorted_array = [2, 6, 3, 7, 8, 4, 1, 5, 9, 10]
print("This shows the array broken up:")
merge_sort(unsorted_array)
print("Sorted array: ", unsorted_array)

#Complexity Analysis
#The merge sort algorithm has a complexity of O[n*logn].
#It has this because the merge sort uses divide and conquer to split the array up into sections, sort, and then merge.
#It is also that because of the recusion we have to do in the subarrays once divided.

#References
#https://www.youtube.com/watch?v=ho05egqcPl4
#https://www.geeksforgeeks.org/python-program-for-merge-sort/
#https://www.youtube.com/watch?v=nCNfu_zNhyI